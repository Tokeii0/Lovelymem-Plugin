### **1. 项目目标**

开发一个高性能的命令行（CLI）工具，旨在：

  * **快速**：利用多线程和高效的 I/O 操作，快速处理 GB 乃至 TB 级别的内存镜像或大文件。
  * **专精**：专注于内存取证场景，能够识别多种编码（ASCII, UTF-8, UTF-16LE, UTF-16BE）的字符串。
  * **强大**：不仅能提取所有满足条件的字符串，还能在提取过程中进行高速搜索（支持普通字符串和正则表达式）。
  * **实用**：将结果以结构化的 CSV 格式输出，方便后续在 Excel、Python/Pandas 等工具中进行数据分析。

### **2. 核心功能**

  * **多线程处理**：可指定工作线程数，充分利用多核 CPU 性能。
  * **大文件支持**：使用内存映射（mmap）技术，避免将整个文件读入内存，支持远超物理内存大小的文件。
  * **多种编码识别**：
      * 单字节 ASCII (7-bit)
      * UTF-8
      * UTF-16 Little Endian
      * UTF-16 Big Endian
  * **字符串提取定制**：
      * 可设置最小字符串长度（`-n` 或 `--min-len`），过滤掉无意义的短字符串。
  * **高级搜索**：
      * 支持搜索包含特定子串的字符串。
      * 支持使用正则表达式进行模式匹配搜索。
  * **结构化输出**：
      * 将结果输出到指定的 CSV 文件。
      * CSV 表格包含关键信息：文件偏移量（十进制和十六进制）、字符串内容、编码格式、字符串长度。
  * **用户友好**：
      * 清晰的命令行接口。
      * 处理大文件时显示进度条。

### **3. 技术选型 (Rust Crates)**

选择合适的库是成功的关键。以下是推荐的核心依赖：

  * **CLI 框架**: `clap` (v4+)
      * **理由**: 功能强大、易于使用，能快速构建出功能丰富、文档齐全的命令行接口。
  * **并行计算**: `rayon`
      * **理由**: Rust 生态中最流行和易用的并行处理库，可以轻松地将迭代器并行化，完美契合文件分块处理的场景。
  * **高效文件 I/O**: `memmap2`
      * **理由**: 提供了跨平台的内存映射文件功能。它将文件内容映射到虚拟内存地址，让我们可以像操作内存中的字节切片一样操作文件，速度极快，且内存占用低。
  * **CSV 生成**: `csv`
      * **理由**: 功能完善、性能优秀的 CSV 读写库。
  * **正则表达式**: `regex`
      * **理由**: Rust 官方维护的高性能正则表达式库。
  * **进度条**: `indicatif`
      * **理由**: 在终端中创建美观且易于使用的进度条。
  * **错误处理**: `anyhow` 或 `thiserror`
      * **理由**: `anyhow` 用于简化应用程序的错误链处理，`thiserror` 用于创建具体的错误类型，两者结合使用效果更佳。

### **4. CLI 接口设计**

使用 `clap` 来定义工具的用法。

```bash
# 示例用法
memstrap [OPTIONS] <FILE_PATH>

# 参数 (Arguments)
<FILE_PATH>              要扫描的内存镜像或文件路径

# 选项 (Options)
-o, --output <FILE>      指定输出的 CSV 文件路径 (默认为标准输出 a.k.a. stdout)
-n, --min-len <LENGTH>   设置要提取的字符串的最小长度 (默认为 4)
-j, --threads <NUM>      设置使用的线程数 (默认为 CPU 核心数)
-s, --search <PATTERN>   搜索包含特定模式的字符串 (可以是普通文本或正则表达式)
-r, --regex              将 --search 的模式解释为正则表达式
    --no-progress        禁用进度条显示
-e, --encoding <TYPE>... 指定要搜索的编码类型 (可多次使用, 如: -e ascii -e utf16le)
                         可选值: ascii, utf8, utf16le, utf16be (默认为全部)
    --help               打印帮助信息
    --version            打印版本信息
```

### **5. 核心实现思路**

这是整个项目的技术核心。

#### **A. 文件处理与分块 (File Handling & Chunking)**

1.  **内存映射 (mmap)**：使用 `memmap2` 打开目标文件。这会返回一个 `Mmap` 对象，它可以被当作一个巨大的字节切片 `&[u8]` 来使用，而无需担心内存消耗。
2.  **计算分块**：
      * 获取文件总大小和用户指定的线程数 `N`。
      * 将文件虚拟地分割成 `N` 个大小基本相等的块（chunk）。
      * **关键点**：为了防止字符串在块的边界处被切断，每个块需要与其相邻的块有一定的重叠区域。重叠区域的大小应大于或等于可能的最长字符串编码单元（例如，UTF-16 字符是 2 字节，但我们可以设置一个更安全的重叠，比如 256 字节）。

#### **B. 多线程实现 (Multithreading with Rayon)**

1.  创建一个包含所有块信息的 `Vec`（每个元素包含块的起始位置和结束位置）。
2.  使用 Rayon 的 `par_iter()` 方法将这个 `Vec` 转换为一个并行迭代器。
3.  在 `map()` 或 `flat_map()` 操作中，为每个块启动一个工作任务。每个任务接收一个块的范围，然后对 `mmap` 的相应切片进行扫描。
4.  每个线程独立地执行字符串提取和搜索逻辑，并返回一个 `Vec<FoundString>` 的结果。
5.  使用 `collect()` 将所有线程的结果汇总到一个最终的 `Vec` 中。

#### **C. 字符串提取与搜索逻辑 (Per-Thread Logic)**

这是在每个线程内部对分配到的数据块执行的逻辑。

1.  **迭代字节**：遍历分配到的字节切片。
2.  **识别编码与候选字符串**：
      * **ASCII/UTF-8**: 扫描连续的可打印 ASCII 字符（`0x20` 到 `0x7e`）。当遇到一个潜在的起始字符时，持续向后读取，直到遇到非打印字符或块的末尾。收集到的字节序列如果满足最小长度，则尝试用 `std::str::from_utf8` 解码。成功则为 UTF-8，失败则视为纯 ASCII。
      * **UTF-16LE/BE**: 扫描字节对。一个常见的模式是 ASCII 字符后跟一个 `0x00`（LE）或 `0x00` 后跟一个 ASCII 字符（BE）。当发现一个潜在的 UTF-16 字符串时（例如，`'H', 0x00, 'e', 0x00, ...`），持续读取，直到遇到两个连续的 `0x00`（null terminator）或模式中断。收集到的字节序列需要满足最小长度（例如，`min_len * 2` 字节）。
3.  **应用搜索过滤器 (`--search`)**:
      * 如果用户提供了搜索模式：
          * 对于提取出的每个候选字符串，检查它是否 `contains()` 该模式（普通搜索）。
          * 如果启用了 `--regex`，则使用 `regex::Regex` 对象来匹配候选字符串。
      * 只有匹配成功的字符串才会被保留。
4.  **构建结果**：对于每个符合条件的字符串，创建一个结构体 `FoundString`，包含：
      * `offset`: 全局文件偏移量（块的起始偏移量 + 在块内的偏移量）。
      * `content`: 提取到的字符串。
      * `encoding`: `enum Encoding { ASCII, UTF8, UTF16LE, UTF16BE }`。
      * `byte_length`: 字符串在文件中占用的原始字节数。

#### **D. CSV 输出 (CSV Output)**

1.  在所有线程完成后，主线程会得到一个包含所有 `FoundString` 的巨大 `Vec`。
2.  （可选）可以对结果按偏移量进行排序，使输出更有序。
3.  使用 `csv::Writer`，首先写入表头：`"FilePath", "Offset(Hex)", "Offset(Dec)", "Encoding", "Length", "Content"`。
4.  遍历结果 `Vec`，将每个 `FoundString` 对象的字段格式化并写入 CSV 文件的一行。

### **6. 项目结构建议**

```
memstrap/
├── Cargo.toml
└── src/
    ├── main.rs         # CLI 解析、任务分发、进度条管理
    ├── lib.rs          # 声明公共模块
    ├── config.rs       # 定义命令行配置结构体 (Config)
    ├── extractor.rs    # 核心的字符串提取和搜索逻辑
    ├── output.rs       # CSV 输出逻辑
    └── error.rs        # 自定义错误类型
```

### **7. 开发步骤建议**

1.  **步骤一：项目初始化**
      * `cargo new memstrap`
      * 在 `Cargo.toml` 中添加 `clap`, `rayon`, `memmap2`, `csv`, `indicatif`, `anyhow` 等依赖。
2.  **步骤二：CLI 框架搭建**
      * 在 `main.rs` 和 `config.rs` 中，使用 `clap` 定义所有命令行参数，并解析成一个 `Config` 结构体。
3.  **步骤三：单线程核心逻辑**
      * 暂时不考虑多线程，在 `extractor.rs` 中实现对一个 `&[u8]` 切片进行 ASCII 字符串提取的功能。
      * 在 `main.rs` 中，使用 `memmap2` 打开文件，并将整个文件切片传递给提取函数。
      * 先实现打印到标准输出。
4.  **步骤四：扩展编码支持**
      * 在 `extractor.rs` 中增加对 UTF-16LE 和 UTF-16BE 的识别逻辑。
5.  **步骤五：集成多线程**
      * 在 `main.rs` 中实现文件分块（带重叠）的逻辑。
      * 使用 `rayon::par_iter` 将分块并行化处理，调用 `extractor.rs` 中的函数，并收集结果。
6.  **步骤六：实现 CSV 输出**
      * 在 `output.rs` 中编写函数，接收 `Vec<FoundString>` 和输出路径，并使用 `csv` 库生成文件。
7.  **步骤七：实现搜索和过滤功能**
      * 在 `extractor.rs` 的核心逻辑中，加入对 `--search` 和 `--regex` 选项的处理。
8.  **步骤八：完善用户体验**
      * 集成 `indicatif`，在 `rayon` 处理数据的同时更新进度条。
      * 编写完善的错误处理和帮助文档。
9.  **步骤九：测试与优化**
      * 编写单元测试和集成测试。
      * 使用性能分析工具（如 `perf`）对真实的大文件进行测试，寻找并优化性能瓶颈。
